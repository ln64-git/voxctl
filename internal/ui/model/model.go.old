// model.go

package model

import (
	"fmt"
	"net/http"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/ln64-git/voxctl/internal/server"
)

type Model struct {
	Choices       []string
	Cursor        int
	Selected      map[int]struct{}
	OutputMessage string
	outputChan    chan string
}

func InitialModel() *Model {
	return &Model{
		Choices: []string{
			"serve ‚ñ∫",
			"play ‚ñ∂",
			"stop ‚ñ†",
			"pause ‚è∏",
			"resume ‚ñ∂ ",
			"clear üóë",
		},
		Selected:   make(map[int]struct{}),
		outputChan: make(chan string),
	}
}

func (m *Model) Init() tea.Cmd {
	return nil
}

func (m *Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmd tea.Cmd
	select {
	case msg := <-m.outputChan:
		// Update OutputMessage with the received message
		m.OutputMessage = msg
	default:
	}
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "ctrl+c", "q":
			return m, tea.Quit

		case "up", "k":
			if m.Cursor > 0 {
				m.Cursor--
			}

		case "down", "j":
			if m.Cursor < len(m.Choices)-1 {
				m.Cursor++
			}

		case "enter", " ":
			_, ok := m.Selected[m.Cursor]
			if ok {
				delete(m.Selected, m.Cursor)
			} else {
				m.Selected[m.Cursor] = struct{}{}
			}

			switch m.Choices[m.Cursor] {
			case "serve ‚ñ∫":
				go func() {
					err := server.Start()
					if err != nil {
						m.outputChan <- "Failed to Start: " + err.Error()
					} else {
						// Server has started successfully, notify and update message
						m.outputChan <- "Server Started"
					}
				}()

			case "play ‚ñ∂":
				go func() {
					resp, err := http.Post("http://localhost:3000/play", "application/json", nil)
					if err != nil {
						m.outputChan <- "Error calling play endpoint"
					} else {
						resp.Body.Close()
						m.outputChan <- "Play request sent"
					}
				}()

			case "stop ‚ñ†":
				go func() {
					resp, err := http.Post("http://localhost:3000/stop", "application/json", nil)
					if err != nil {
						m.outputChan <- "Error calling stop endpoint"
					} else {
						resp.Body.Close()
						m.outputChan <- "Stop request sent"
					}
				}()

			case "pause ‚è∏":
				go func() {
					resp, err := http.Post("http://localhost:3000/pause", "application/json", nil)
					if err != nil {
						m.outputChan <- "Error calling pause endpoint"
					} else {
						resp.Body.Close()
						m.outputChan <- "Pause request sent"
					}
				}()

			case "resume ‚ñ∂ ":
				go func() {
					resp, err := http.Post("http://localhost:3000/resume", "application/json", nil)
					if err != nil {
						m.outputChan <- "Error calling resume endpoint"
					} else {
						resp.Body.Close()
						m.outputChan <- "Resume request sent"
					}
				}()

			case "clear üóë":
				// Implement clear logic
			}
		}
	}
	return m, cmd
}

func (m *Model) View() string {
	var s string

	// Define styles for output message, cursor, options, and footer
	outputStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#acacac")).Background(lipgloss.Color("#283460")).Bold(true)
	cursorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#02af78")).Bold(true)
	optionStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#bababa"))
	selectedOptionStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#646cd4"))
	footerStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#6a6a6a"))

	// Create a goroutine to continuously listen for updates on outputChan
	go func() {
		for {
			select {
			case msg := <-m.outputChan:
				// Update OutputMessage with the received message
				m.OutputMessage = msg
			}
		}
	}()

	// Display the output message
	if m.OutputMessage != "" {
		s += outputStyle.Render(" - " + m.OutputMessage + " - ")
	} else {
		s += outputStyle.Render(" Select Option ")
	}

	s += "\n\n"

	// Render choices with cursor
	for i, choice := range m.Choices {
		cursor := " "
		if m.Cursor == i {
			cursor = cursorStyle.Render("-")
			choice = selectedOptionStyle.Render(choice)
		} else {
			choice = optionStyle.Render(choice)
		}

		s += fmt.Sprintf("%s %s\n", cursor, choice)
	}

	s += footerStyle.Render("\nPress q to quit.")

	return s
}
