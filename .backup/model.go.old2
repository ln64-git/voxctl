package 

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/ln64-git/voxctl/internal/server"
)

type model struct {
	choices      []string
	cursor       int
	selected     int
	messages     []string
	textInput    string
	inputFocused bool
}

func InitialModel() model {
	return model{
		choices:  []string{"serve", "play", "stop", "pause", "resume", "clear", "input"},
		selected: -1,
	}
}

func (m model) Init() tea.Cmd {
	return nil
}

func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "ctrl+c":
			return m, tea.Quit
		case "up":
			if !m.inputFocused && m.cursor > 0 {
				m.cursor--
			}
		case "down":
			if !m.inputFocused && m.cursor < len(m.choices)-1 {
				m.cursor++
			}
		case "enter":
			if m.cursor == len(m.choices)-1 {
				m.inputFocused = !m.inputFocused
			} else if !m.inputFocused {
				m.selected = m.cursor

				choice := m.choices[m.selected]
				switch choice {
				case "serve":
					go func() {
						err := server.Start()
						if err != nil {
							m.messages = append(m.messages, fmt.Sprintf("Server error: %v", err))
						}
					}()
					m.messages = append(m.messages, "Server started")
				case "play":
					messageChan := make(chan string)
					go func() {
						payload := map[string]string{"text": m.textInput}
						jsonPayload, _ := json.Marshal(payload)

						resp, err := http.Post("http://localhost:3000/play", "application/json", bytes.NewBuffer(jsonPayload))
						if err != nil {
							messageChan <- fmt.Sprintf("Request error: %v", err)
							close(messageChan)
							return
						}
						defer resp.Body.Close()

						if resp.StatusCode >= 200 && resp.StatusCode < 300 {
							messageChan <- "play request successful"
						} else {
							messageChan <- fmt.Sprintf("Play request failed, status code: %d", resp.StatusCode)
						}
						close(messageChan)
					}()
					for msg := range messageChan {
						m.messages = append(m.messages, msg)
					}

				case "stop", "pause", "resume":
					messageChan := make(chan string)
					go func() {
						resp, err := http.Post(fmt.Sprintf("http://localhost:3000/%s", choice), "application/json", nil)
						if err != nil {
							messageChan <- fmt.Sprintf("Request error: %v", err)
							close(messageChan)
							return
						}
						defer resp.Body.Close()

						if resp.StatusCode >= 200 && resp.StatusCode < 300 {
							messageChan <- fmt.Sprintf("%s request successful", choice)
						} else {
							messageChan <- fmt.Sprintf("%s request failed, status code: %d", choice, resp.StatusCode)
						}
						close(messageChan)
					}()
					for msg := range messageChan {
						m.messages = append(m.messages, msg)
					}
				case "clear":
					m.messages = nil
					m.textInput = ""
				}
			}

		default:
			if m.inputFocused {
				if msg.String() == "backspace" {
					if len(m.textInput) > 0 {
						m.textInput = m.textInput[:len(m.textInput)-1]
					}
				} else {
					m.textInput += msg.String()
				}
			}
		}
	case tea.WindowSizeMsg:
		// Handle window resizing if needed
	}
	return m, nil
}

func (m model) View() string {
	outputStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#acacac")).Background(lipgloss.Color("#283460")).Bold(true)
	cursorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#02af78")).Bold(true)
	optionStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#bababa"))
	selectedOptionStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#646cd4"))
	footerStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#6a6a6a"))
	// inputStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#ffffff")).Background(lipgloss.Color("#4a4a4a"))
	// selectedInputStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#de8c56")).Background(lipgloss.Color("#4a4a4a"))

	var sb strings.Builder

	// Render the latest output message
	if len(m.messages) > 0 {
		msg := m.messages[len(m.messages)-1] // Get the last message
		sb.WriteString(outputStyle.Render(" " + msg + " "))
	} else {
		sb.WriteString(outputStyle.Render(" Select Option "))
	}
	if m.textInput != "" {
		sb.WriteString(optionStyle.Render("\n" + m.textInput))
	} else {
		sb.WriteString(outputStyle.Render("\n"))
	}
	sb.WriteString(outputStyle.Render("\n"))

	// Render choices with cursor and styles
	for i, choice := range m.choices {
		cursor := " "
		if m.cursor == i {
			cursor = cursorStyle.Render("-")
			choice = selectedOptionStyle.Render(choice)
		} else {
			choice = optionStyle.Render(choice)
		}
		sb.WriteString(fmt.Sprintf("%s %s\n", cursor, choice))
	}

	sb.WriteString("\n" + footerStyle.Render("Press 'ctrl+c' to exit."))

	return sb.String()
}
